1.1.1  
CREATE TABLE book(
    book_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(50),
    author VARCHAR(30),
    price DECIMAL(8, 2),
    amount INT
);

1.1.2  
INSERT INTO book (title, author, price, amount) 
VALUES ('Мастер и Маргарита', 'Булгаков М.А.', 670.99, 3);

1.1.3  
INSERT INTO book (title, author, price, amount) 
VALUES ('Белая гвардия', 'Булгаков М.А.', 540.50, 5);

INSERT INTO book (title, author, price, amount) 
VALUES ('Идиот', 'Достоевский Ф.М.', 460.00, 10);

INSERT INTO book (title, author, price, amount) 
VALUES ('Братья Карамазовы', 'Достоевский Ф.М.', 799.01, 2);

____________________________________________________________

1.2.1  
SELECT * FROM book;

1.2.2  
SELECT author, title, price FROM book;

1.2.3  
SELECT title AS Название, author AS Автор FROM book;

1.2.4  
SELECT title, amount, 
    1.65 * amount AS pack 
FROM book;

1.2.5  
SELECT title, author, amount, 
    ROUND(0.7 * price, 2) AS new_price 
FROM book;

1.2.6  
SELECT author, title, 
    ROUND(IF(author = "Булгаков М.А.", price * 1.1, 
             IF(author = "Есенин С.А.", price * 1.05, price)), 
          2) AS new_price 
    FROM book;

1.2.7  
SELECT author, title, price
FROM book
WHERE amount < 10;

1.2.8  
SELECT title, author, price, amount 
FROM book
WHERE (price < 500 OR price > 600) AND price * amount > 5000;

1.2.9  
SELECT title, author 
  FROM book
 WHERE price BETWEEN 540.50 AND 800
   AND amount IN (2, 3, 5, 7);

1.2.10  
  SELECT author, title
    FROM book
   WHERE amount BETWEEN 2 AND 14
ORDER BY author DESC, title;

1.2.11  
  SELECT title, author FROM book
   WHERE title LIKE "%_ _%"
         AND (author LIKE "% С.%"
              OR author LIKE "%.С.%")
ORDER BY title;
__________________________________________________________

1.3.1
SELECT DISTINCT amount
FROM book;

1.3.2
  SELECT author as 'Автор', COUNT(author) as 'Различных_книг', SUM(amount) as 'Количество_экземпляров'
    FROM book
GROUP BY author;

1.3.3
  SELECT author,
         MIN(price) AS 'Минимальная_цена',
         MAX(price) AS 'Максимальная_цена',
         AVG(price) AS 'Средняя_цена'
    FROM book
GROUP BY author;

1.3.4
  SELECT author,
         SUM(amount * price) AS Стоимость,
         ROUND(SUM(amount * price) * 0.18 / 1.18, 2) AS НДС,
         ROUND(SUM(amount * price) / 1.18, 2) AS Стоимость_без_НДС
    FROM book
GROUP BY author;

1.3.5
SELECT MIN(price) AS Минимальная_цена,
       MAX(price) AS Максимальная_цена,
       ROUND(AVG(price), 2) AS Средняя_цена
FROM book;

1.3.6
SELECT ROUND(AVG(price), 2)          AS Средняя_цена,
       ROUND(SUM(price * amount), 2) AS Стоимость
  FROM book
 WHERE amount BETWEEN 5 AND 14

1.3.7
   SELECT author,
          SUM(price * amount) AS Стоимость
     FROM book
    WHERE title NOT IN ('Идиот', 'Белая гвардия')
 GROUP BY author
   HAVING Стоимость > 5000
 ORDER BY Стоимость DESC;
____________________________________________________

1.4.1
  SELECT author, title, price
    FROM book
   WHERE price <= (SELECT AVG(price) FROM book)
ORDER BY price DESC;

1.4.2
  SELECT author, title, price
    FROM book
   WHERE price - (SELECT MIN(price) FROM book) <= 150
ORDER BY price;

1.4.3
SELECT author, title, amount
  FROM book
 WHERE amount IN (
                    SELECT amount
                      FROM book
                  GROUP BY amount
                    HAVING COUNT(amount) = 1
              );

1.4.4
SELECT author, title, price
FROM book
WHERE price < ANY (
                     SELECT MIN(price)
                       FROM book
                   GROUP BY author
              );

1.4.5
SELECT title, author, amount, (SELECT MAX(amount) FROM book) - amount AS Заказ
FROM book
HAVING Заказ > 0;
__________________________________________________________________________

1.5.1
CREATE TABLE supply(
    supply_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(50),
    author VARCHAR(30),
    price DECIMAL(8, 2),
    amount INT
);

1.5.2
INSERT INTO supply (title, author, price, amount)
VALUES
    ('Лирика', 'Пастернак Б.Л.', 518.99, 2),
    ('Черный человек', 'Есенин С.А.', 570.20, 6),
    ('Белая гвардия', 'Булгаков М.А.', 540.50, 7),
    ('Идиот', 'Достоевский Ф.М.', 360.80, 3);

1.5.3
INSERT INTO book (title, author, price, amount)
     SELECT title, author, price, amount
       FROM supply
      WHERE author NOT IN ('Булгаков М.А.', 'Достоевский Ф.М.');

1.5.4
INSERT INTO book (title, author, price, amount)
SELECT title, author, price, amount
  FROM supply
 WHERE author NOT IN (
        SELECT author
          FROM book
      );

1.5.5
UPDATE book
   SET price = 0.9 * price
 WHERE amount BETWEEN 5 AND 10;

1.5.6
UPDATE book
   SET buy = IF (buy > amount, amount, buy),
       price = IF (buy < 1, 0.9 * price, price);

1.5.7
UPDATE book, supply
   SET book.amount = book.amount + supply.amount, book.price = (book.price + supply.price) / 2
 WHERE book.title = supply.title AND book.author = supply.author;

1.5.8
DELETE FROM supply
 WHERE author IN (
                      SELECT author
                        FROM book
                    GROUP BY author
                      HAVING SUM(amount) > 10
              );

1.5.9
CREATE TABLE ordering AS
SELECT author,
       title,
       (
       SELECT ROUND(AVG(amount))
         FROM book
       ) AS amount
  FROM book
 WHERE amount < (SELECT ROUND(AVG(amount))
                  FROM book
               );

___________________________________________________________________

1.6.1
   SELECT name, city, per_diem, date_first, date_last
     FROM trip
    WHERE name LIKE "%а %"
 ORDER BY date_last DESC;

1.6.2
  SELECT DISTINCT name
    FROM trip
   WHERE city = 'Москва'
ORDER BY name;

1.6.3
  SELECT DISTINCT city, COUNT(city) AS Количество
    FROM trip
GROUP BY city
ORDER BY city;

1.6.4
SELECT
    city,
    COUNT(city) AS Количество
FROM
    trip
GROUP BY
    city
ORDER BY
    Количество DESC
LIMIT
    2;

1.6.5
SELECT
  name,
  city,
  DATEDIFF(date_last, date_first) + 1 AS "Длительность"
FROM
  trip
WHERE
  city NOT IN (
    "Москва", "Санкт-Петербург"
  )
ORDER BY
  Длительность DESC,
  city DESC;

1.6.6
SELECT
  name,
  city,
  date_first,
  date_last
FROM
  trip
WHERE
  datediff(date_last, date_first) = (
    SELECT
      MIN(
        datediff(date_last, date_first)
      )
    FROM
      trip
  );

1.6.7
SELECT
  name,
  city,
  date_first,
  date_last
FROM
  trip
WHERE
  MONTH(date_first) = MONTH(date_last)
ORDER BY
  city,
  name;

1.6.8
SELECT
  MONTHNAME(date_first) AS Месяц,
  COUNT(date_first) AS Количество
FROM
  trip
GROUP BY
  Месяц
ORDER BY
  Количество DESC,
  Месяц;

1.6.9
SELECT
  name,
  city,
  date_first,
  (
    DATEDIFF(date_last, date_first) + 1
  ) * per_diem AS Сумма
FROM
  trip
WHERE
  MONTHNAME(date_first) = "March"
  OR MONTHNAME(date_first) = "February"
ORDER BY
  name,
  Сумма DESC;

1.6.10
SELECT
  name,
  SUM(
    (
      DATEDIFF(date_last, date_first) + 1
    ) * per_diem
  ) AS Сумма
FROM
  trip
GROUP BY
  name
HAVING
  COUNT(name) > 3
ORDER BY
  Сумма DESC;
__________________________________________

1.7.1
CREATE TABLE fine(
    fine_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(30),
    number_plate VARCHAR(6),
    violation VARCHAR(30),
    sum_fine DECIMAL(8, 2),
    date_violation DATE,
    date_payment DATE
);

1.7.2
INSERT INTO fine VALUES
    (NULL, 'Баранов П.Е.', 'Р523ВТ', 'Превышение скорости(от 40 до 60)', NULL, '2020-02-14', NULL),
    (NULL, 'Абрамова К.А.', 'О111АВ', 'Проезд на запрещающий сигнал', NULL, '2020-02-23', NULL),
    (NULL, 'Яковлев Г.Р.', 'Т330ТТ', 'Проезд на запрещающий сигнал', NULL, '2020-03-03', NULL);

SELECT * FROM fine;

1.7.3
UPDATE
    fine AS f,
    traffic_violation AS tv
SET
    f.sum_fine = tv.sum_fine
WHERE
    f.sum_fine IS Null
    and  tv.violation = f.violation;

1.7.4
SELECT
  name,
  number_plate,
  violation
FROM
  fine
GROUP BY
  name,
  number_plate,
  violation
HAVING
  COUNT(*) > 1
ORDER BY
  name,
  number_plate,
  violation;

1.7.5
UPDATE
  fine,
  // создаем промежуточную таблицу для нахождения повторных нарушений/нарушителей/машин
  (
    SELECT
      name,
      number_plate,
      violation
    FROM
      fine
    GROUP BY
      name,
      number_plate,
      violation
    HAVING
      COUNT(*) > 1
    ORDER BY
      name,
      number_plate,
      violation
  ) AS query_in
SET
  sum_fine = 2 * sum_fine
// по промежуточной таблице ищем соответствующие записи с неоплатами
WHERE
  date_payment is null
  AND query_in.name = fine.name
  AND query_in.number_plate = fine.number_plate
  AND query_in.violation = fine.violation;

1.7.6
UPDATE
    fine,
    payment
SET
    sum_fine = IF(
                    DATEDIFF(payment.date_payment, payment.date_violation) > 20,
                    sum_fine,
                    0.5 * sum_fine
                ),
    fine.date_payment = payment.date_payment
WHERE
    // "выравняются" строки, у которых есть 3 совпадения?
    (fine.name, fine.violation, fine.date_violation)
    = (payment.name, payment.violation, payment.date_violation);

1.7.7
DELETE FROM fine
WHERE date_violation < '2020-02-01';

SELECT * FROM fine;
_______________________________________________
_______________________________________________
_______________________________________________

2.1.1
CREATE TABLE author(
    author_id INT PRIMARY KEY AUTO_INCREMENT,
    name_author VARCHAR(50)
);

2.1.2
INSERT INTO author (title, author, price, amount)
VALUES
    ('Идиот', 'Достоевский Ф.М.', 460, 10),
    ('Братья Карамазовы', 'Достоевский Ф.М.', 799.01, 2);

2.1.3
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(50),
    author_id INT NOT NULL,
    genre_id INT,
    price DECIMAL(8,2),
    amount INT,
    FOREIGN KEY (author_id)  REFERENCES author (author_id),
    FOREIGN KEY (genre_id)  REFERENCES genre (genre_id)
);

2.1.4
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(50),
    author_id INT NOT NULL,
    genre_id INT,
    price DECIMAL(8,2),
    amount INT,
    FOREIGN KEY (author_id) REFERENCES author (author_id) ON DELETE CASCADE,
    FOREIGN KEY (genre_id) REFERENCES genre (genre_id) ON DELETE SET NULL
);

2.1.5
INSERT INTO book
VALUES
    (NULL, 'Стихотворения и поэмы', 3, 2, 650.00, 15),
    (NULL, 'Черный человек', 3, 2, 570.20, 6),
    (NULL, 'Лирика', 4, 2, 518.99, 2);

2.2.1
SELECT
  title,
  name_genre,
  price
FROM
  book
  INNER JOIN genre ON book.genre_id = genre.genre_id
WHERE
  amount > 8
ORDER BY
  price DESC;

2.2.2
SELECT
  name_genre
FROM
  genre
  LEFT JOIN book ON genre.genre_id = book.genre_id
WHERE
  amount is NULL;

2.2.3
SELECT
    city.name_city,
    author.name_author,
    DATE_ADD('2020-01-01',INTERVAL FLOOR(RAND() * 365) DAY) AS Дата
FROM
    author,
    city
ORDER BY
    city.name_city,
    Дата DESC;

2.2.4
SELECT
    name_genre,
    title,
    name_author
FROM
    book
    INNER JOIN genre ON book.genre_id = genre.genre_id
    INNER JOIN author ON book.author_id = author.author_id
WHERE
    name_genre = 'Роман'
ORDER BY
    title;

2.2.5
SELECT
    name_author,
    SUM(amount) AS Количество
FROM
    author
    LEFT JOIN book ON author.author_id = book.author_id
GROUP BY
    name_author
HAVING
    Количество < 10
    OR Количество is NULL
ORDER BY
    Количество;

2.2.6
SELECT
    name_author
FROM
    (SELECT
        author_id,
        COUNT(DISTINCT genre_id) AS genre_number
    FROM
        book
    GROUP BY
        author_id
    HAVING
        genre_number = 1
    ) AS one_love_author
    JOIN author ON author.author_id = one_love_author.author_id
ORDER BY
    name_author;

2.2.7
SELECT
  title,
  name_author,
  name_genre,
  price,
  amount

FROM
  author
  INNER JOIN book ON author.author_id = book.author_id
  INNER JOIN genre ON book.genre_id = genre.genre_id

WHERE
  genre.genre_id IN (

    /* выбираем автора, если он пишет книги в самых популярных жанрах*/
    SELECT
      query_in_1.genre_id
    FROM

      (
        /* выбираем код жанра и количество произведений, относящихся к нему */
        SELECT
          genre_id,
          SUM(amount) AS sum_amount
        FROM
          book
        GROUP BY
          genre_id
      ) query_in_1

      INNER JOIN

      (
      /* выбираем запись, в которой указан код жанр с максимальным количеством книг */
      SELECT
        genre_id,
        SUM(amount) AS sum_amount
      FROM
        book
      GROUP BY
        genre_id
      ORDER BY
        sum_amount DESC
      LIMIT
        1
        ) query_in_2 ON query_in_1.sum_amount = query_in_2.sum_amount
  )

ORDER BY
  title;

2.2.8
SELECT
    book.title AS Название,
    name_author AS Автор,
    book.amount + supply.amount AS Количество
FROM
    book
    INNER JOIN author ON book.author_id = author.author_id
    INNER JOIN supply ON book.title = supply.title
                         and author.name_author = supply.author
                         and book.price = supply.price;
________________________________

2.3.1
UPDATE book
    INNER JOIN author ON book.author_id = author.author_id
    INNER JOIN supply ON book.title = supply.title
                        AND supply.author = author.name_author
SET book.amount = book.amount + supply.amount,
    supply.amount = 0,
    book.price = (book.price * book.amount + supply.price * supply.amount) / (book.amount + supply.amount)
WHERE book.price != supply.price;

2.3.2
INSERT INTO author (author.name_author)
SELECT supply.author
FROM
    author
    RIGHT JOIN supply ON author.name_author = supply.author
WHERE author.name_author IS Null;

2.3.3
INSERT INTO book
SELECT
    NULL AS book_id,
    title,
    author_id,
    NULL AS genre_id,
    price,
    amount
FROM
    author
    INNER JOIN supply ON author.name_author = supply.author
WHERE amount <> 0;

2.3.4
UPDATE book
SET genre_id =
      (
       SELECT genre_id
       FROM genre
       WHERE name_genre = 'Поэзия'
      )
WHERE book.title = 'Стихотворения и поэмы';

UPDATE book
SET genre_id =
      (
       SELECT genre_id
       FROM genre
       WHERE name_genre = 'Приключения'
      )
WHERE book.title = 'Остров сокровищ';

SELECT * FROM book;

2.3.5
DELETE FROM
    author
WHERE
    author_id IN (SELECT
                        author_id
                    FROM
                        book
                    GROUP BY
                        author_id
                    HAVING
                        SUM(amount) < 20
                   );

2.3.6
DELETE FROM
    genre
WHERE
    genre.genre_id IN (SELECT
                        genre_id
                        FROM
                            book
                        GROUP BY
                            genre_id
                        HAVING
                            COUNT(book.title) < 4
                       );

2.3.7
DELETE FROM
    author
USING
    author
    INNER JOIN book ON author.author_id = book.author_id
    INNER JOIN genre ON genre.genre_id = book.genre_id
WHERE
    genre.name_genre = 'Поэзия';
____________________________________________________

2.4.1
SELECT
    buy.buy_id,
    book.title,
    book.price,
    buy_book.amount
FROM
    buy_book
    INNER JOIN buy USING (buy_id)
    INNER JOIN book USING (book_id)
    INNER JOIN client USING (client_id)
WHERE
    client.name_client LIKE '%Баранов%Павел%'
ORDER BY
    buy.buy_id,
    book.title;

2.4.2
SELECT
    author.name_author,
    book.title,
    COUNT(buy_book.book_id) AS Количество
FROM
    book
    LEFT JOIN buy_book USING (book_id)
    INNER JOIN author USING (author_id)
GROUP BY
    book.book_id
ORDER BY
    author.name_author,
    book.title;

2.4.3
SELECT
    city.name_city,
    COUNT(buy.buy_id) AS Количество
FROM
    client
    INNER JOIN buy USING (client_id)
    INNER JOIN city USING (city_id)
GROUP BY
    city.city_id
ORDER BY
    Количество DESC,
    city.name_city;

2.4.4
SELECT
    buy_step.buy_id,
    buy_step.date_step_end
FROM
    step
    INNER JOIN buy_step
    ON step.step_id = buy_step.step_id
    AND buy_step.date_step_end IS NOT NULL
    AND step.name_step = 'Оплата';

Условия в JOINe или в WHERE?
В данном случае запросы одинаковые у СУБД получились,
даже в WHERE чуть "менее сложно" почему-то

в JOINe:
EXPLAIN ANALYZE
SELECT DISTINCT buy_id, date_step_end
FROM
    buy_step
    INNER JOIN step ON buy_step.step_id=step.step_id AND name_step='Оплата' AND date_step_end IS NOT NULL
+-----------------------------------------------------------------------------------------------------------------------------+
| EXPLAIN                                                                                                                     |
+-----------------------------------------------------------------------------------------------------------------------------+
| -> Table scan on <temporary>  (cost=0.20..2.65 rows=13) (actual time=0.001..0.001 rows=3 loops=1)                           |
|     -> Temporary table with deduplication  (cost=4.00..6.45 rows=13) (actual time=0.290..0.291 rows=3 loops=1)              |
|         -> Inner hash join (buy_step.step_id = step.step_id)  (cost=2.50 rows=13) (actual time=0.043..0.050 rows=3 loops=1) |
|             -> Filter: (buy_step.date_step_end is not null)  (cost=1.85 rows=14) (actual time=0.009..0.014 rows=9 loops=1)  |
|                 -> Table scan on buy_step  (cost=1.85 rows=16) (actual time=0.009..0.012 rows=16 loops=1)                   |
|             -> Hash                                                                                                         |
|                 -> Filter: (step.name_step = 'Оплата')  (cost=0.65 rows=1) (actual time=0.017..0.020 rows=1 loops=1)        |
|                     -> Table scan on step  (cost=0.65 rows=4) (actual time=0.014..0.016 rows=4 loops=1)                     |
|                                                                                                                             |
+-----------------------------------------------------------------------------------------------------------------------------+

в WHERE:
EXPLAIN ANALYZE
SELECT DISTINCT buy_id, date_step_end
FROM
    buy_step
    INNER JOIN step ON buy_step.step_id=step.step_id
WHERE
    name_step='Оплата' AND date_step_end IS NOT NULL
+-----------------------------------------------------------------------------------------------------------------------------+
| EXPLAIN                                                                                                                     |
+-----------------------------------------------------------------------------------------------------------------------------+
| -> Table scan on <temporary>  (cost=0.20..2.65 rows=13) (actual time=0.001..0.001 rows=3 loops=1)                           |
|     -> Temporary table with deduplication  (cost=3.70..6.15 rows=13) (actual time=0.138..0.139 rows=3 loops=1)              |
|         -> Inner hash join (buy_step.step_id = step.step_id)  (cost=2.20 rows=13) (actual time=0.038..0.044 rows=3 loops=1) |
|             -> Filter: (buy_step.date_step_end is not null)  (cost=1.85 rows=14) (actual time=0.008..0.013 rows=9 loops=1)  |
|                 -> Table scan on buy_step  (cost=1.85 rows=16) (actual time=0.008..0.011 rows=16 loops=1)                   |
|             -> Hash                                                                                                         |
|                 -> Filter: (step.name_step = 'Оплата')  (cost=0.35 rows=1) (actual time=0.013..0.018 rows=1 loops=1)        |
|                     -> Table scan on step  (cost=0.35 rows=1) (actual time=0.010..0.014 rows=4 loops=1)                     |
|                                                                                                                             |
+-----------------------------------------------------------------------------------------------------------------------------+

2.4.5
SELECT
    buy.buy_id,
    client.name_client,
    SUM(buy_book.amount * book.price) AS Стоимость
FROM
    client
    INNER JOIN buy USING (client_id)
    INNER JOIN buy_book USING (buy_id)
    INNER JOIN book USING (book_id)
GROUP BY
    buy.buy_id
ORDER BY
    buy.buy_id;
//почему нет ошибки: client.name_client не участвует ни в группировкеЮ ни в агрегировании?

2.4.6
SELECT
    buy_step.buy_id,
    step.name_step
FROM
    step
    INNER JOIN buy_step ON step.step_id = buy_step.step_id
WHERE
    buy_step.date_step_beg IS NOT NULL and  buy_step.date_step_end IS NULL
ORDER BY
    buy_step.buy_id

2.4.7
SELECT
    buy_step.buy_id,
    DATEDIFF(buy_step.date_step_end, buy_step.date_step_beg) AS Количество_дней,
    IF(DATEDIFF(buy_step.date_step_end, buy_step.date_step_beg) > city.days_delivery
       , DATEDIFF(buy_step.date_step_end, buy_step.date_step_beg) - city.days_delivery
       , 0
    ) AS Опоздание
FROM
    buy_step
    INNER JOIN step ON step.step_id = buy_step.step_id
    INNER JOIN buy ON buy.buy_id = buy_step.buy_id
    INNER JOIN client ON client.client_id = buy.client_id
    INNER JOIN city ON client.city_id = city.city_id
WHERE
    step.name_step = "Транспортировка"
    AND buy_step.date_step_beg IS NOT NULL
    AND buy_step.date_step_end IS NOT NULL
ORDER BY
    buy_step.buy_id;

2.4.8
SELECT
    DISTINCT client.name_client
FROM
    buy_book
    INNER JOIN book USING (book_id)
    INNER JOIN author ON author.author_id = book.author_id AND author.name_author LIKE "Достоевский%"
    INNER JOIN buy USING (buy_id)
    INNER JOIN client USING (client_id)
ORDER BY
    client.name_client;

2.4.9
SELECT
    genre.name_genre AS name_genre,
    SUM(buy_book.amount) AS Количество
FROM
    buy_book
    INNER JOIN book USING (book_id)
    INNER JOIN genre USING (genre_id)
GROUP BY
    genre.genre_id
HAVING
    Количество
    = (
        SELECT
           MAX(Количества) AS Максимальное_количество
        FROM(
            SELECT
                SUM(buy_book.amount) AS Количества
            FROM
                buy_book
                INNER JOIN book USING (book_id)
                INNER JOIN genre USING (genre_id)
            GROUP BY
                genre.genre_id
        ) AS Таблица_количеств
    )
;

2.4.10
SELECT
    YEAR(ba.date_payment) Год,
    MONTHNAME(ba.date_payment) Месяц,
    SUM(ba.price * ba.amount) Сумма
FROM
    buy_archive ba
GROUP BY
    MONTHNAME(ba.date_payment),
    YEAR(ba.date_payment)

UNION ALL

SELECT
    YEAR(bs.date_step_end),
    MONTHNAME(bs.date_step_end),
    SUM(book.price * bb.amount)
FROM
    buy
    JOIN buy_step bs USING (buy_id)
    JOIN buy_book bb USING (buy_id)
    JOIN book USING (book_id)
WHERE
    bs.date_step_end IS NOT NULL &&
    bs.step_id = 1
GROUP BY
    MONTHNAME(bs.date_step_end),
    YEAR(bs.date_step_end)

ORDER BY
    Месяц,
    Год;

2.4.11
SELECT
    pivot_table.title,
    SUM(Количество) Количество,
    SUM(Сумма) Сумма

FROM
    (SELECT
        ba.book_id,
        book.title title,
        ba.amount Количество,
        ba.price * ba.amount Сумма
    FROM
        buy_archive ba
        JOIN book USING (book_id)
    WHERE
        ba.date_payment IS NOT NULL

    UNION ALL

    SELECT
        bb.book_id,
        book.title title,
        bb.amount,
        book.price * bb.amount
    FROM
        buy_book bb
        JOIN book USING (book_id)
        JOIN buy USING (buy_id)
        JOIN buy_step bs USING (buy_id)
        JOIN step USING (step_id)
    WHERE
        step.name_step = "Оплата" AND
        bs.date_step_end IS NOT NULL
    ) AS pivot_table

GROUP BY
    pivot_table.book_id,
    pivot_table.title

ORDER BY
    Сумма DESC;

________________________________________________

2.5.1
INSERT INTO
    client (client.name_client, client.city_id, client.email)
SELECT
    'Попов Илья'
    , city_id
    , 'popov@test'
FROM
    city
WHERE
    city.name_city = 'Москва';

2.5.2
INSERT INTO
    buy (buy.buy_description, client_id)
SELECT
    "Связаться со мной по вопросу доставки"
    , client_id
FROM
    client
WHERE
    client.name_client = "Попов Илья";

2.5.3
INSERT INTO
    buy_book (buy_book.book_id, buy_book.buy_id, buy_book.amount)
SELECT
    book_id
    , 5
    , 2
FROM
    book
    , author
WHERE
    author.name_author LIKE "Пастернак%"
    AND book.title = "Лирика";

INSERT INTO
    buy_book (buy_book.book_id, buy_book.buy_id, buy_book.amount)
SELECT
    book_id
    , 5
    , 1
FROM
    book
    , author
WHERE
    author.name_author LIKE "Булгаков%"
    AND book.title = "Белая гвардия";

2.5.4
UPDATE
    book
    JOIN buy_book
    ON buy_book.book_id = book.book_id
SET
    book.amount = book.amount - buy_book.amount
WHERE
    buy_book.buy_id = 5;

2.5.5
CREATE TABLE buy_pay AS
SELECT
    b.title,
    a.name_author,
    b.price,
    bb.amount,
    b.price * bb.amount AS Стоимость
FROM
    buy_book AS bb
    JOIN book AS b USING (book_id)
    JOIN author AS a USING (author_id)
WHERE
    bb.buy_id = 5
ORDER BY
    b.title;

2.5.6
CREATE TABLE buy_pay AS
SELECT
    bb.buy_id,
    SUM(bb.amount) AS Количество,
    SUM(bb.amount * book.price) AS Итого
FROM
    buy_book AS bb
    JOIN book USING (book_id)
WHERE
    bb.buy_id = 5;

SELECT * FROM buy_pay;

2.5.7
INSERT INTO buy_step (buy_id, step_id)
SELECT
   5,
   step.step_id
FROM
    step;

2.5.8
UPDATE
    buy_step
    JOIN step USING (step_id)
SET
    buy_step.date_step_beg = '2020-04-12'
WHERE
    buy_step.buy_id = 5 &&
    step.name_step = 'Оплата';

2.5.9
UPDATE
    buy_step bs
    JOIN step USING (step_id)
SET
    bs.date_step_end = "2020-04-13"
WHERE
    bs.buy_id = 5 AND
    step.name_step = "Оплата";

UPDATE
    buy_step bs
    JOIN step USING (step_id)
SET
    bs.date_step_beg = "2020-04-13"
WHERE
    bs.buy_id = 5 AND
    step.name_step = "Упаковка";

--------------------------------------
--------------------------------------

3.1.1
SELECT
    st.name_student,
    att.date_attempt,
    att.result
FROM
    attempt AS att
    JOIN student AS st USING (student_id)
    JOIN subject AS sub USING (subject_id)
WHERE
    sub.name_subject = "Основы баз данных"
ORDER BY
    att.result DESC;

3.1.2
SELECT
    subject.name_subject,
    COUNT(attempt.attempt_id) AS Количество,
    ROUND(AVG(attempt.result), 2) AS Среднее
FROM
    attempt
    RIGHT JOIN subject USING(subject_id)
GROUP BY
    subject_id
ORDER BY
    Среднее DESC;

3.1.3
SELECT
    DISTINCT student.name_student,
    result
FROM
    attempt
    JOIN student USING(student_id)
WHERE
    attempt.result = (SELECT
                          MAX(result)
                      FROM
                          attempt
    )
ORDER BY
    student.name_student

3.1.4
SELECT
    std.name_student,
    sub.name_subject,
    DATEDIFF(MAX(att.date_attempt), MIN(att.date_attempt)) AS Интервал
FROM
    attempt AS att
    JOIN student AS std USING(student_id)
    JOIN subject AS sub USING(subject_id)
GROUP BY
    std.name_student,
    sub.name_subject
HAVING
    count(att.attempt_id) > 1
ORDER BY
    Интервал;

3.1.5
SELECT
    sub.name_subject,
    COUNT(DISTINCT att.student_id) AS Количество
FROM
    attempt AS att
    RIGHT JOIN subject AS sub USING(subject_id)
GROUP BY
    sub.name_subject
ORDER BY
    Количество DESC,
    sub.name_subject;

3.1.6
SELECT
    question.question_id,
    question.name_question
FROM
    question
    JOIN subject USING (subject_id)
WHERE
    subject.name_subject = "Основы баз данных"
ORDER BY RAND()
LIMIT
    3;

3.1.7
SELECT
    qst.name_question,
    ans.name_answer,
    IF (
        ans.is_correct = 0,
        "Неверно",
        "Верно"
    ) AS Результат
FROM
    testing AS tst
    JOIN question AS qst USING (question_id)
    JOIN answer AS ans USING (answer_id)
WHERE
    tst.attempt_id = 7;

3.1.8
SELECT
    stu.name_student,
    sub.name_subject,
    att.date_attempt,
    ROUND(SUM(ans.is_correct) / 3 * 100, 2) Результат
FROM
    attempt att
    JOIN testing tst USING (attempt_id)
    JOIN student stu USING (student_id)
    JOIN subject sub USING (subject_id)
    JOIN answer ans USING (answer_id)
GROUP BY
    stu.name_student,
    sub.name_subject,
    att.date_attempt
ORDER BY
    stu.name_student,
    att.date_attempt DESC;
/*
а можно и:
GROUP BY
    tst.attempt_id
так надо ли все неагрегируемые поля указывать в GROUP BY?
*/

3.1.9
SELECT
    sub.name_subject,
    CONCAT(SUBSTR(qst.name_question, 1, 30), '...') AS Вопрос,
    COUNT(ans.answer_id) AS Всего_ответов,
    ROUND(100 * SUM(ans.is_correct) / COUNT(ans.answer_id), 2) AS Успешность
FROM
    subject sub
    INNER JOIN question qst USING (subject_id)
    INNER JOIN answer ans USING (question_id)
    INNER JOIN testing tst USING (answer_id)
GROUP BY
    sub.name_subject,
    qst.name_question
ORDER BY
    sub.name_subject,
    Успешность DESC,
    Вопрос

------------------------------------------------

3.2.1
INSERT INTO attempt (student_id, subject_id , date_attempt )
VALUES (
    (SELECT student_id FROM student WHERE name_student = "Баранов Павел"),
    (SELECT subject_id FROM subject WHERE name_subject = "Основы баз данных"),
    CURRENT_DATE()
);

3.2.2
INSERT INTO
    testing (attempt_id, question_id)
SELECT
    att.attempt_id,
    qst.question_id
FROM
    question qst
    JOIN attempt att USING (subject_id)
WHERE
    att.attempt_id = (SELECT MAX(attempt_id) FROM attempt)
ORDER BY RAND()
LIMIT
    3;

3.2.3
UPDATE
    attempt
SET
    result = (
            SELECT
                ROUND(SUM(is_correct) / 3 * 100)
            FROM
                testing
                INNER JOIN answer USING (answer_id)
            WHERE
                attempt_id = 8)
WHERE
    attempt_id = 8

3.2.4
DELETE FROM
    attempt
WHERE
    date_attempt < '2020-05-01'

-------------------------------------------------

3.3.1
SELECT
    enr.name_enrollee
FROM
    program_enrollee AS pe
    JOIN enrollee AS enr USING(enrollee_id)
    JOIN program AS prg USING(program_id)
WHERE
    prg.name_program = "Мехатроника и робототехника"
ORDER BY
    enr.name_enrollee

3.3.2
SELECT
    prg.name_program
FROM
    program_subject AS prs
    JOIN subject AS sub USING (subject_id)
    JOIN program AS prg USING (program_id)
WHERE
    sub.name_subject = "Информатика"
ORDER BY
    prg.name_program DESC

3.3.3
SELECT
    sub.name_subject,
    COUNT(ens.subject_id) AS Количество,
    MAX(ens.result) AS Максимум,
    MIN(ens.result) AS Минимум,
    ROUND(AVG(ens.result), 1) AS Среднее
FROM
    enrollee_subject AS ens
    JOIN subject AS sub USING (subject_id)
GROUP BY
    sub.name_subject
ORDER BY
    sub.name_subject

3.3.4
SELECT
    prg.name_program
FROM
    program_subject AS prs
    JOIN program as prg USING (program_id)
GROUP BY
    prg. program_id
HAVING
    MIN(prs.min_result) >= 40
ORDER BY
    prg.name_program;

3.3.5
SELECT
    name_program,
    plan
FROM
    program
WHERE
    plan = (
        SELECT
            MAX(plan)
        FROM
            program);

3.3.6
SELECT
    name_enrollee,
    IFNULL(SUM(bonus), 0) AS Бонус
FROM
    enrollee_achievement AS ea
    JOIN achievement AS ach USING (achievement_id)
    RIGHT JOIN enrollee AS enr USING (enrollee_id)
GROUP BY
    name_enrollee
ORDER BY
    name_enrollee;

3.3.7
SELECT
    dpr.name_department,
    prg.name_program,
    prg.plan,
    COUNT(pe.enrollee_id) AS Количество,
    ROUND(COUNT(pe.enrollee_id) / prg.plan, 2) AS Конкурс
FROM
    program_enrollee AS pe
    JOIN program AS prg USING (program_id)
    JOIN department AS dpr USING (department_id)
GROUP BY
    prg.program_id
ORDER BY
    Конкурс DESC;

3.3.8
SELECT
    prg.name_program
FROM
    program_subject AS prs
    JOIN program AS prg USING (program_id)
    JOIN subject AS sub USING (subject_id)
WHERE
    sub.name_subject in ('Информатика', 'Математика')
GROUP BY
    prg.name_program
HAVING
    COUNT(prg.name_program) = 2
ORDER BY
    prg.name_program;

3.3.9
SELECT
    prg.name_program,
    enr.name_enrollee,
    SUM(es.result) itog
FROM
    enrollee enr
    INNER JOIN program_enrollee pe USING (enrollee_id)
    INNER JOIN program prg USING (program_id)
    INNER JOIN program_subject ps USING (program_id)
    /* важное место, не совсем мною понятое
    соединение по 2 ключам */
    INNER JOIN enrollee_subject es
        ON ps.subject_id = es.subject_id
            AND es.enrollee_id = enr.enrollee_id
GROUP BY
    prg.name_program,
    enr.name_enrollee
ORDER BY
    prg.name_program,
    itog DESC

3.3.10
SELECT
  prg.name_program,
  enr.name_enrollee
FROM
  enrollee enr
  INNER JOIN program_enrollee pre ON pre.enrollee_id = enr.enrollee_id
  INNER JOIN program prg ON pre.program_id = prg.program_id
  INNER JOIN program_subject prs ON prs.program_id = prg.program_id
  /* важное место, не совсем мною понятое
    соединение по 2 ключам */
  INNER JOIN enrollee_subject ens
    ON enr.enrollee_id = ens.enrollee_id AND ens.subject_id = prs.subject_id
WHERE
  ens.result < prs.min_result
ORDER BY
  prg.name_program,
  enr.name_enrollee

-------------------------------------------------

3.4.1
CREATE TABLE
    applicant AS
SELECT
    pe.program_id,
    pe.enrollee_id,
    SUM(es.result) itog
FROM
    program_enrollee pe
    INNER JOIN program_subject ps USING (program_id)
    INNER JOIN enrollee_subject es
        ON ps.subject_id = es.subject_id
            AND es.enrollee_id = pe.enrollee_id
GROUP BY
    pe.program_id,
    pe.enrollee_id
ORDER BY
    pe.program_id,
    itog DESC;

SELECT * FROM applicant

3.4.2
DELETE FROM applicant app
WHERE (app.program_id, app.enrollee_id) IN (
        SELECT
          pre.program_id,
          pre.enrollee_id
        FROM
          program_enrollee pre
          INNER JOIN program_subject prs ON prs.program_id = pre.program_id
          INNER JOIN enrollee_subject ens
            ON pre.enrollee_id = ens.enrollee_id AND ens.subject_id = prs.subject_id
        WHERE
          ens.result < prs.min_result);

SELECT * FROM applicant

3.4.3
WITH bonus AS(
        SELECT
            enrollee_id,
            IFNULL(SUM(bonus), 0) Бонус
        FROM
            enrollee_achievement AS ea
            JOIN achievement AS ach USING (achievement_id)
        GROUP BY
            enrollee_id
        )

UPDATE applicant app
INNER JOIN bonus USING(enrollee_id)
SET itog = itog + Бонус;

SELECT * FROM applicant;

3.4.4
CREATE TABLE applicant_order AS
SELECT * FROM applicant ORDER BY program_id, itog DESC;
-- SELECT * FROM applicant_order;
DROP TABLE applicant

3.4.5
ALTER TABLE applicant_order ADD str_id INT FIRST

3.4.6
SET @num_pr := 1;
SET @row_num := 0;

UPDATE applicant_order
SET str_id = if(program_id = @num_pr, @row_num := @row_num + 1, @row_num := 1 AND @num_pr := @num_pr + 1);
-- вообще-то @row_num := 1 AND @num_pr := num_pr + 1 - это хак.
-- Результатом AND будет как раз True = единица, которая запишется, где надо.
-- А потом уже работаем с @row_num.
-- Красивый хак: @row_num := 1 + (@num_pr := program_id)*0

-- SELECT * FROM applicant_order

3.4.7
CREATE TABLE student AS
SELECT
    prg.name_program,
    enr.name_enrollee,
    apo.itog
FROM
    applicant_order apo
    INNER JOIN enrollee enr USING (enrollee_id)
    INNER JOIN program prg USING (program_id)
WHERE
    apo.str_id <= prg.plan
ORDER BY
    prg.name_program,
    apo.itog DESC;

SELECT * FROM student

-------------------------------------------------

3.5.1
SELECT
    CONCAT(LEFT(CONCAT(m.module_id, ' ', m.module_name), 16), '...') Модуль,
    CONCAT(LEFT(CONCAT(m.module_id, '.', l.lesson_position, ' ', l.lesson_name), 16), '...') Урок,
    -- надо было IF, конечно, на случай если строка <= 16 + 3 знаков, но я поленилсся
    CONCAT(m.module_id, '.', l.lesson_position, '.', s.step_position, ' ', s.step_name) Шаг
FROM step s
    JOIN lesson l USING (lesson_id)
    JOIN module m USING (module_id)
WHERE
    s.step_name LIKE '%влож%'
ORDER BY
    m.module_id,
    l.lesson_position,
    s.step_position

3.5.2
INSERT INTO
    step_keyword
SELECT
    s.step_id,
    k.keyword_id
FROM
    step s,
    keyword k
WHERE
    s.step_name REGEXP CONCAT('\\b', k.keyword_name, '\\b');
